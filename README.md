# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных по курсу "Логическое программирование"
## Введение
Любой список в Прологе можно представить как двоичное дерево. Элементами списка могут быть любые объекты. Список состоит из головы и хвоста, хвост сам является списком.

Не во всех императивных языках есть такая структура данных, как список. Обрабатывать элементы списка в Прологе можно только рекурсивно, разделяя список на голову и хвост. В императивных языках, чтобы обратиться к какому-то элементу списка, мы можем использовать итераторы. Список в императивном языке может содержать в себе элементы одианкового типа, в Прологе списки содержат любые элементы.

## Задание 1.1: Предикат обработки списка
`my_search(X,[X,Y|_],Y)` - осуществляет поиск элемента списка, следующего за данным без использования стандартных предикатов, `find_next(X,X1,List)` - использует стандартные предикаты.
Пример использования:
```prolog
?- my_search(7,[4,5,6,9,2,7,1,4,5,6],Y).
Y = 1 .

?- find_next(6,X1,[1,2,5,8,7,46,6,9,8]).
X1 = 9 .
```
Реализация
```prolog
my_search(X,[X,Y|_],Y).
my_search(X,[_|T],Y):-
				my_search(X,T,Y).
```
Рекурсивно обрезаем список, пока не дойдем до нужного элемента и выводим следующий.

```prolog
my_find(X,[X|_],Pos,Pos).
my_find(X,[_|Tail],CurPose,Pos):-
				CurPose1 is CurPose + 1,
				my_find(X,Tail,CurPose1,Pos).
my_find(X,List,Pos):- my_find(X,List,0,Pos).

find_next(X,X1,List):-
				my_find(X,List,Pos),
				delete(List,X,Res),
				my_find(X1,Res,Pos).
 ```
 С помощью редиката `my_find` находим позицию элемента, после которого нужно выводить, удаляем его в `find_next`, тем самым смещая искомый элемент на уже найденную позицию и выводим его.
 
 ## Задание 1.2: Предикат обработки числового списка
 `even_odd([E,O|Tail], [E|Tail1], [O|Tail2])` - разделяет список на два списка по приципу четности.
 Ппример использования:
 ```prolog
 ?- even_odd([1,2,3,4,5,6,7,8,9],L1,L2).
L1 = [1, 3, 5, 7],
L2 = [2, 4, 6, 8, 9] .

?- even_odd([5,8,4,7,9,6,3,2,54,5,6,6,8,5],L1,L2).
L1 = [5, 4, 9, 3, 54, 6, 8],
L2 = [8, 7, 6, 2, 5, 6, 5] .
```
Реализация
```prolog
even_odd([E,O|Tail], [E|Tail1], [O|Tail2]):-
				even_odd(Tail,Tail1,Tail2).
even_odd(L,[],L).

```
Обрезаем два елемента, первый поместим в первый список, следующий элемент во второй. 

## Задание 2: Реляционное представление данных

Реляционное представление показывает отношения между объектами, а задачей программиста является анализ этих отношений. Результат запроса к таким данным - это множество ответов, удовлетворяющих внутренней структуре программы. Вся задача сводится к реализации такой структуры, которая обеспечит выдачу ответов. Это вынуждает постоянно проверять выходные данные на правильность и полноту.  К преимуществам можно отнести относительную простоту разработки: программа разбивается на отдельные компоненты, которые реализуются независимо друг от друга.

Мое представление удобно тем, что информация по каждому ученику вынесена в отделный элемент и между собой данные об учениках не связаны. Поэтому с помощью функции findall я могу получать любые списки, с нужной мне информацией.

Я выбрал 2 вариант:
1 задание: Напечатать средний балл для каждого предмета.
Из-за проблем с кирилицей, мне пришлось использовать английский язык.
Пример
```prolog
?- sum_grades('functional programming',S).
S = 3.8214285714285716.

?- sum_grades('functional programming',S).
S = 3.8214285714285716.

?- sum_grades('logic programming',S).
S = 3.892857142857143.

?- sum_grades(english,S).
S = 4.178571428571429.

?- sum_grades(psychology,S).
S = 3.607142857142857.

?- sum_grades(informatics,S).
S = 3.4642857142857144.
?- sum_grades('logic programming',S).
S = 3.892857142857143.
```
Реализация
```prolog
sum_list([],0).
sum_list([H|T],Sum):-
				sum_list(T,Sum1),
				Sum is H + Sum1.


sum_grades(Sub,S):-
				subject(Y,Sub),
				findall(X,grade(_,Y,X),C),
				sum_list(C,Sum),
				length(C,Len),
				S is Sum / Len.
 ```
 
 Сначала получаем сокращенное название предмета, получаем список всех оценок по нему, получаем сумму, находим длину спика и считаем средний балл.
 
 2 задание: Для каждой группы, найти количество несдавших студентов
 
 `find_not_pass(G,N)` - количество студентов, несдавших экзамены в заданной группе.
 Пример
 ```prolog
 ?- find_not_pass(103,N).
N = 3 .

?- find_not_pass(102,N).
N = 9 .

?- find_not_pass(101,N).
N = 2 .
```
Реализация
```prolog
find_not_pass(G,N):- findall(X,student(G,X),C),
					all_marks(C,L),
					count_dont_pass(L,N).

%Список вех оценок группы
all_marks([],[]).
all_marks([H|T],List):- findall(X,grade(H,_,X),C), !, remove_same(C,R), all_marks(T,L1), append(R,L1,List).
%удаляем повторяющиеся
delete_all(_,[],[]).
delete_all(X,[X|L],L1):-delete_all(X,L,L1).
delete_all(X,[Y|L],[Y|L1]):- X \= Y, delete_all(X,L,L1).

remove_same([],[]).
remove_same([H|T],[H|T1]):-delete_all(H,T,T2), remove_same(T2,T1).
%подсчет
count_dont_pass([],0).
count_dont_pass([H|T],N):- H < 3,!, count_dont_pass(T,N1), N is (N1 + 1).
count_dont_pass([_|T],N):-count_dont_pass(T,N).
```
Получаем список студентов группы, получаем список всех их оценок, убираем все повторяющиеся оценки, выводим количество двоек в полученном списке.

3 задание: Найти количество несдавших студентов для каждого из предметов

`sub_notes(Sub,S)` - количество несдавших для заданного предмета
Пример
```prolog
?- sub_notes('english',S).
S = 1.

?- sub_notes('informatics',S).
S = 4.

?- sub_notes('logic programming',S).
S = 4.

?- sub_notes('functional programming',S).
S = 2.
```
Реализация
```prolog
kp([],0):-!.
kp([X|T],K):- X < 3, !, kp(T,K1), K is (K1 + 1).
kp([_|T],K):-kp(T,K).


sub_notes(Sub,S):-
				subject(Y,Sub),
				findall(X,grade(_,Y,X),C),
				kp(C,N),
				S is N.
```
Получаем сокращенное название предмета, находим все оценки по нему, считаем количество двоек.

## Вывод
В Прологе, в отличие от императивных языков программирования, мы указываем, что необходимо сделать, а не как. Мы сообщаем известные нам данные и правила, после задаем вопросы для получения нужных данных. Пролог идеален для работы со сложными и комплексными логическими задачами, ведь нам не нужно прописывать правила нахождения решения, Пролог сделает это за нас. 
